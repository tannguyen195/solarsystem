(this.webpackJsonpsolarsystem=this.webpackJsonpsolarsystem||[]).push([[4],{66:function(e,n,t){"use strict";t.d(n,"a",(function(){return s}));var r=t(13),i=t(11),a=t(16),o=function(e){return e===Object(e)&&!Array.isArray(e)&&"function"!==typeof e};function s(e){var n=Object(a.f)(i.TextureLoader,o(e)?Object.values(e):e);if(o(e)){var t=Object.keys(e),s={};return t.forEach((function(e){return Object.assign(s,Object(r.a)({},e,n[t.indexOf(e)]))})),s}return n}s.preload=function(e){return a.f.preload(i.TextureLoader,e)},s.clear=function(e){return a.f.clear(i.TextureLoader,e)}},67:function(e,n,t){"use strict";t.r(n);var r=t(10),i=t(26),a=t(5),o=t(16),s=t(66),c=t(17),l=t(11),u=t(9);var v=function(e){var n=e.size,t=e.innerDiameter,r=e.facets,i=e.color,a=e.name,o=e.distance,s=e.layers;return Object(u.jsxs)("mesh",{layers:s,name:a,rotation:[Math.PI/2,0,0],position:[o,0,0],children:[Object(u.jsx)("ringBufferGeometry",{args:[n,t,r]}),Object(u.jsx)("meshStandardMaterial",{attach:"material",side:l.DoubleSide,color:i})]})};var m=function(e){var n=e.name,t=e.rotationRate,m=e.orbitRate,x=e.size,p=e.texture,f=e.axialTilt,b=e.bumpMap,j=e.specularMap,d=e.earthCloud,y=e.distanceScale,h=e.planetGeometry,O=Object(s.a)({map:p,bumpMap:b,specularMap:j}),g=Object(s.a)({map:d}),z=Object(a.useRef)(),w=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name}));return Object(o.e)((function(e){e.scene;var r=Date.now();w!==n&&"moon"!==w&&(z.current.rotation.y+=.1*t,z.current.position.x=Math.sin(r*(1/(200*m))+10)*y,z.current.position.z=Math.cos(r*(1/(200*m))+10)*y)})),Object(u.jsxs)(u.Fragment,{children:[Object(u.jsxs)("mesh",{layers:2,scale:x,rotation:f,name:n,position:[y,0,0],ref:z,children:[h,Object(u.jsx)("meshPhongMaterial",Object(r.a)(Object(r.a)({attach:"material"},O),{},{shininess:0,bumpScale:.005,specular:new l.Color("grey")})),Object(u.jsxs)("mesh",{layers:2,children:[Object(u.jsx)("sphereBufferGeometry",{args:[x+.005,48,48]}),Object(u.jsx)("meshPhongMaterial",Object(r.a)(Object(r.a)({},g),{},{attach:"material",transparent:!0}))]})]}),Object(u.jsx)(v,Object(r.a)(Object(r.a)({},i.a.orbitData),{},{layers:2}))]})},x=t(47);var p=function(e){var n=e.layer,t=Object(a.useRef)(),i=Object(s.a)({map:x.a});return Object(o.e)((function(e){var n,r=null===(n=e.scene.getObjectByName("saturn"))||void 0===n?void 0:n.position;t.current.position.x=r.x,t.current.position.z=r.z})),Object(u.jsxs)("mesh",{layer:n,ref:t,position:[0,0,0],name:"saturnRing",rotation:[Math.PI/2*-26.73,0,0],children:[Object(u.jsx)("torusBufferGeometry",{args:[20,4,2,50]}),Object(u.jsx)("meshBasicMaterial",Object(r.a)(Object(r.a)({attach:"material"},i),{},{side:l.DoubleSide}))]})};var f=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,l=e.size,m=e.texture,x=e.distanceScale,f=e.axialTilt,b=e.orbitData,j=e.layers,d=e.planetGeometry,y=Object(s.a)({map:m}),h=Object(a.useRef)(),O=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name}));return Object(o.e)((function(e){var r=e.scene,a=Date.now();if(h.current.rotation.y+=.1*t,n!==O&&(h.current.position.x=Math.sin(a*(1/(200*i))+10)*x,h.current.position.z=Math.cos(a*(1/(200*i))+10)*x,"moon"===n)){var o,s=null===(o=r.getObjectByName("earth"))||void 0===o?void 0:o.position;h.current.position.x=h.current.position.x+s.x,h.current.position.z=h.current.position.z+s.z}})),Object(u.jsxs)("group",{children:[Object(u.jsxs)("mesh",{layers:j,scale:l,rotation:f,name:n,position:[x,0,0],ref:h,children:[d,Object(u.jsx)("meshPhongMaterial",Object(r.a)(Object(r.a)({attach:"material"},y),{},{shininess:0,bumpScale:.3}))]})," ",Object(u.jsx)(v,Object(r.a)(Object(r.a)({},b),{},{layers:j})),"saturn"===n&&Object(u.jsx)(p,{layers:j})]})};var b=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,l=e.size,v=e.texture,m=e.distanceScale,x=e.axialTilt,p=e.planetGeometry,f=e.layer,b=e.sphere,j=Object(s.a)({map:v}),d=Object(a.useRef)(),y=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name})),h=Object(o.g)().scene;return Object(o.e)((function(){var e=Date.now();if(d.current.rotation.y+=.1*t,n!==y){var r;d.current.position.x=Math.sin(e*(1/(200*i))+10)*m,d.current.position.z=Math.cos(e*(1/(200*i))+10)*m;var a=null===(r=h.getObjectByName("earth"))||void 0===r?void 0:r.position;d.current.position.x=a.x+d.current.position.x/10,d.current.position.z=a.z+d.current.position.z/10}})),Object(u.jsxs)("mesh",{geometry:b,layers:f,scale:l,rotation:x,name:n,position:[0,0,0],ref:d,children:[p,Object(u.jsx)("meshPhongMaterial",Object(r.a)(Object(r.a)({attach:"material"},j),{},{shininess:0,bumpScale:.3}))]})},j=t(12),d=t(1),y=t(2),h=t(3),O=t(4);var g=function(e){Object(h.a)(t,e);var n=Object(O.a)(t);function t(){return Object(d.a)(this,t),n.call(this,{extensions:{derivatives:"#extension GL_OES_standard_derivatives: enable"},side:l.DoubleSide,uniforms:{time:{value:0},resolution:{value:new l.Vector4}},vertexShader:"\n    uniform float time;\n    varying vec3 vPosition;\n \n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    void main() {\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n  varying vec3 vPosition;\n\n  float PI = 3.14159265359;\n    \n  // Description : Array and textureless GLSL 2D/3D/4D simplex \n  //               noise functions.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : stegu\n  //     Lastmod : 20110822 (ijm)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //               https://github.com/ashima/webgl-noise\n  //               https://github.com/stegu/webgl-noise\n  // \n\n  vec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n  float mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n  vec4 permute(vec4 x) {\n      return mod289(((x*34.0)+10.0)*x);\n  }\n\n  float permute(float x) {\n      return mod289(((x*34.0)+10.0)*x);\n  }\n\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  float taylorInvSqrt(float r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  vec4 grad4(float j, vec4 ip)\n    {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n    return p;\n    }\n              \n  // (sqrt(5) - 1)/4 = F4, used once below\n  #define F4 0.309016994374947451\n\n  float snoise(vec4 v)\n    {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n    i = mod289(i); \n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n              i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n    }\n\n    float fbm(vec4 p) {\n      float sum = 0.;\n      float amp = 1.;\n      float scale = 1.;\n      for(int i = 0;i < 8;i++) {\n        sum += snoise(p*scale)*amp;\n        p.w += 100.;\n        amp *= .9;\n        scale += 2.;\n      }\n      return sum;\n    }\n  void main() {\n    vec4 p = vec4(vPosition*.4,time*0.005);\n    float noisy = fbm(p);\n\n    vec4 p1 = vec4(vPosition*.2,time*.005);\n    float spots = max(snoise(p1), 0.);\n\n    gl_FragColor = vec4(noisy);\n    gl_FragColor *= mix(1., spots, 0.5);\n  }\n  "})}return Object(y.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}}]),t}(l.ShaderMaterial);Object(o.d)({SunMaterial:g});var z=function(e){Object(h.a)(t,e);var n=Object(O.a)(t);function t(){return Object(d.a)(this,t),n.call(this,{extensions:{derivatives:"#extension GL_OES_standard_derivatives: enable"},side:l.DoubleSide,uniforms:{time:{value:0},uPerlin:{value:null},resolution:{value:new l.Vector4}},vertexShader:"\n    uniform float time;\n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    \n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n  \n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    mat2 rotate(float a) {\n      float s = sin(a);\n      float c = cos(a);\n      return mat2(c, -s, s, c);\n    }\n    \n    void main() {\n      vNormal = normal;\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      eyeVector = normalize(worldPosition.xyz - cameraPosition);\n\n      float t = time*.005;\n\n      mat2 rot = rotate(t);\n      vec3 p0 = position;      \n      p0.yz = rot*p0.yz;\n      vLayer0 = p0;\n\n      mat2 rot1 = rotate(t*1.5 + 10.);\n      vec3 p1 = position;      \n      p1.xz = rot1*p1.xz;\n      vLayer1 = p1;\n\n      mat2 rot2 = rotate(t*2.0 + 30.);\n      vec3 p2 = position;      \n      p2.xy = rot2*p2.xy;\n      vLayer2 = p2;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n  uniform samplerCube uPerlin;\n\n  varying vec3 eyeVector;\n  varying vec3 vNormal;\n\n  float PI = 3.14159265359;\n  \n  varying vec3 vLayer0;\n  varying vec3 vLayer1;\n  varying vec3 vLayer2;\n\n  float Fresnel(vec3 eyeVector, vec3 worldNormal) {\n    return pow(1.0 + dot(eyeVector, worldNormal),3.0);\n  }\n\n  vec3 brightnessToColor(float b) {\n    b *= 0.25;\n    return (vec3(b, b*b, b*b*b*b)/0.25)*0.6;\n  }\n  \n  float supersun() {\n    float sum = 0.;\n    sum += textureCube(uPerlin, vLayer0).r;\n    sum += textureCube(uPerlin, vLayer1).r;\n    sum += textureCube(uPerlin, vLayer2).r;\n    sum += 0.33;\n    return sum;\n  }\n\n  void main() {\n   float brightness = supersun();\n   brightness = brightness*.9 + 1.;\n\n   float fres = Fresnel(eyeVector, vNormal);\n\n   brightness += pow(fres,0.8);\n\n   vec3 col = brightnessToColor(brightness);\n\n   gl_FragColor = vec4(col,1.0);\n\n  }\n  "})}return Object(y.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}},{key:"uPerlin",get:function(){return this.uniforms.uPerlin.value},set:function(e){this.uniforms.uPerlin.value=e}}]),t}(l.ShaderMaterial);Object(o.d)({PerlinMaterial:z});var w=function(e){Object(h.a)(t,e);var n=Object(O.a)(t);function t(){return Object(d.a)(this,t),n.call(this,{side:l.BackSide,uniforms:{time:{value:0},resolution:{value:new l.Vector4}},vertexShader:"\n    uniform float time;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    \n    void main() {\n      vPosition = position;\n      vNormal = normal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n\n  varying vec2 vUv;\n  varying vec3 vNormal;\n  varying vec3 vPosition;\n\n  float PI = 3.14159265359;\n\n  vec3 brightnessToColor(float b) {\n    b *= 0.25;\n    return (vec3(b, b*b, b*b*b*b)/0.25)*0.6;\n  }\n  \n  void main() {\n    float radial = 1. - vNormal.z;\n    radial *= radial* radial;\n\n    float brightness = 1. + radial*0.83;\n\n    gl_FragColor.rgb = brightnessToColor(brightness)*radial;\n    gl_FragColor.a = radial;\n    // float intensity = pow(.5 - dot(vNormal, vec3(0.5,0,0.)), 2.);\n    // gl_FragColor = vec4(1., .6, .4, 1.) * intensity;\n  }\n  ",blending:l.AdditiveBlending})}return Object(y.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}},{key:"uPerlin",get:function(){return this.uniforms.uPerlin.value},set:function(e){this.uniforms.uPerlin.value=e}}]),t}(l.ShaderMaterial);Object(o.d)({AroundMaterial:w});var M=function(){var e=Object(a.useRef)(),n=Object(a.useRef)(),t=Object(a.useRef)(),r=Object(a.useMemo)((function(){return[new l.WebGLCubeRenderTarget(256,{format:l.RGBFormat,generateMipmaps:!0,minFilter:l.LinearMipMapLinearFilter,encoding:l.sRGBEncoding})]}),[]),i=Object(j.a)(r,1)[0];Object(o.e)((function(r,a){n.current.time+=a,e.current.time+=a,e.current.uPerlin=i.texture,t.current.update(r.gl,r.scene)}));var s=Object(a.useMemo)((function(){return Object(u.jsx)("sphereBufferGeometry",{args:[25,40,40]})}),[]);return Object(u.jsxs)(u.Fragment,{children:[Object(u.jsxs)("mesh",{layers:1,name:"sun",position:[0,0,0],children:[s,Object(u.jsx)("sunMaterial",{ref:n})]}),Object(u.jsxs)("mesh",{layers:1,children:[Object(u.jsx)("cubeCamera",{layers:1,name:"cubeCamera",ref:t,position:[0,0,0],args:[.1,26,i]}),s,Object(u.jsx)("perlinMaterial",{ref:e})]})]})};n.default=function(){var e=Object(a.useMemo)((function(){return Object(u.jsx)("sphereBufferGeometry",{args:[1,40,40]})}),[]);return Object(o.e)((function(e){e.camera})),Object(u.jsxs)(u.Fragment,{children:[Object(u.jsx)(M,{}),Object(u.jsx)(m,Object(r.a)(Object(r.a)({},i.a),{},{planetGeometry:e}),i.a.name),Object(u.jsx)(b,Object(r.a)({planetGeometry:e},i.c),i.c.name),i.d.map((function(n){return Object(u.jsx)(f,Object(r.a)({planetGeometry:e},n),n.name)}))]})}}}]);
//# sourceMappingURL=4.d1e4e94c.chunk.js.map