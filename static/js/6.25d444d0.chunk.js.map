{"version":3,"sources":["components/Particle/ParticleMaterial.js","components/Particle/Particle.js"],"names":["ParticleMaterial","uniforms","uTime","value","uPixelRatio","Math","min","window","devicePixelRatio","uSize","vertexShader","fragmentShader","this","v","THREE","extend","Particle","count","scale","position","shader","useRef","useMemo","positionArray","Float32Array","scaleArray","colorArray","i","random","toArray","useFrame","state","delta","current","time","attachObject","array","itemSize","ref","transparent","depthWrite"],"mappings":"yNAGqBA,E,kDACnB,aAAe,uCACP,CACJC,SAAU,CACRC,MAAO,CAAEC,MAAO,GAChBC,YAAa,CAAED,MAAOE,KAAKC,IAAIC,OAAOC,iBAAkB,IACxDC,MAAO,CAAEN,MAAO,MAElBO,aAAa,+0BAoBbC,eAAe,wP,sCAWnB,WACE,OAAOC,KAAKX,SAASC,MAAMC,O,IAG7B,SAASU,GACPD,KAAKX,SAASC,MAAMC,MAAQU,M,GA5CcC,kBAgD9CC,YAAO,CAAEf,qB,YC9CM,SAASgB,EAAT,GAAoD,IAAD,IAA/BC,aAA+B,MAAvB,GAAuB,EAAnBC,EAAmB,EAAnBA,MAAOC,EAAY,EAAZA,SAC9CC,EAASC,mBADiD,EAGhBC,mBAAQ,WAItD,IAHA,IAAMC,EAAgB,IAAIC,aAAqB,EAARP,GACjCQ,EAAa,IAAID,aAAaP,GAC9BS,EAAa,IAAIF,aAAqB,EAARP,GAC3BU,EAAI,EAAGA,EAAIV,EAAOU,IACzB,IAAIb,UACsB,GAAvBT,KAAKuB,SAAW,IACD,IAAhBvB,KAAKuB,SAAiB,EACE,GAAvBvB,KAAKuB,SAAW,KACjBC,QAAQN,EAAmB,EAAJI,GACzBF,EAAWE,GAAKtB,KAAKuB,SACrB,IAAId,UACF,IAAsB,GAAhBT,KAAKuB,SAAgB,EAC3B,IAAsB,GAAhBvB,KAAKuB,SAAgB,GACX,GAAhBvB,KAAKuB,UACLC,QAAQH,EAAgB,EAAJC,GAExB,MAAO,CAACJ,EAAeE,EAAYC,KAClC,CAACT,IArB4D,mBAGzDM,EAHyD,KAG1CE,EAH0C,KAG9BC,EAH8B,KA0BhE,OAHAI,aAAS,SAACC,EAAOC,GACfZ,EAAOa,QAAQC,MAAQF,EAAQ,KAG/B,yBAAQb,SAAUA,EAAUD,MAAOA,EAAnC,UACE,2CACE,iCACEiB,aAAc,CAAC,aAAc,YAC7BlB,MAAOA,EACPmB,MAAOb,EACPc,SAAU,IAEZ,iCACEF,aAAc,CAAC,aAAc,UAC7BlB,MAAOA,EACPmB,MAAOX,EACPY,SAAU,IAEZ,iCACEF,aAAc,CAAC,aAAc,SAC7BlB,MAAOA,EACPmB,MAAOV,EACPW,SAAU,OAGd,kCAAkBC,IAAKlB,EAAQmB,aAAW,EAACC,YAAY,MArBVvB","file":"static/js/6.25d444d0.chunk.js","sourcesContent":["import * as THREE from 'three'\nimport { extend } from '@react-three/fiber'\n\nexport default class ParticleMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        uTime: { value: 0 },\n        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },\n        uSize: { value: 3000 },\n      },\n      vertexShader: `\n      uniform float uPixelRatio;\n      uniform float uSize;\n      uniform float uTime;\n      attribute float aScale;    \n      attribute vec3 color;\n      varying vec3 vColor;\n\n      void main() {\n        vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n        modelPosition.y += sin(uTime + modelPosition.x * 100.0) * aScale * 0.2 * 20.0;\n        modelPosition.z += cos(uTime + modelPosition.x * 100.0) * aScale * 0.2 * 20.0;\n        modelPosition.x += cos(uTime + modelPosition.x * 100.0) * aScale * 0.2 * 20.0;\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectionPostion = projectionMatrix * viewPosition;    \n        gl_Position = projectionPostion;\n        gl_PointSize = uSize * aScale * uPixelRatio ;\n        gl_PointSize *= (1.0 / - viewPosition.z);\n        vColor = color;\n      }`,\n      fragmentShader: `\n      varying vec3 vColor;\n      void main() {\n        float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n        float strength = 0.05 / distanceToCenter - 0.1;\n        \n        gl_FragColor = vec4(vColor, strength);\n      }`,\n    })\n  }\n\n  get time() {\n    return this.uniforms.uTime.value\n  }\n\n  set time(v) {\n    this.uniforms.uTime.value = v\n  }\n}\n\nextend({ ParticleMaterial })\n","import * as THREE from \"three\";\nimport React, { useRef, useMemo } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\nimport \"./ParticleMaterial\";\n\nexport default function Particle({ count = 40, scale, position }) {\n  const shader = useRef();\n\n  const [positionArray, scaleArray, colorArray] = useMemo(() => {\n    const positionArray = new Float32Array(count * 3);\n    const scaleArray = new Float32Array(count);\n    const colorArray = new Float32Array(count * 3);\n    for (let i = 0; i < count; i++) {\n      new THREE.Vector3(\n        (Math.random() - 0.5) * 4,\n        Math.random() * 1.5 * 2,\n        (Math.random() - 0.5) * 4\n      ).toArray(positionArray, i * 3);\n      scaleArray[i] = Math.random();\n      new THREE.Vector3(\n        215 - Math.random() * 10 * 3,\n        215 - Math.random() * 10 * 10,\n        Math.random() * 10\n      ).toArray(colorArray, i * 3);\n    }\n    return [positionArray, scaleArray, colorArray];\n  }, [count]);\n  \n  useFrame((state, delta) => {\n    shader.current.time += delta / 2;\n  });\n  return (\n    <points position={position} scale={scale} key={count}>\n      <bufferGeometry>\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={count}\n          array={positionArray}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"aScale\"]}\n          count={count}\n          array={scaleArray}\n          itemSize={1}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={count}\n          array={colorArray}\n          itemSize={3}\n        />\n      </bufferGeometry>\n      <particleMaterial ref={shader} transparent depthWrite={false} />\n    </points>\n  );\n}\n"],"sourceRoot":""}