(this.webpackJsonpsolarsystem=this.webpackJsonpsolarsystem||[]).push([[7],{71:function(e,n,t){"use strict";t.r(n);var r=t(11),i=t(28),a=t(5),o=t(19),s=t(70),c=t(17),l=t(12),u=t(13),m=t(76),v=t(47),x=t(10);var p=function(e){var n=e.radius,t=e.layers,r=void 0===t?0:t,i=Object(a.useMemo)((function(){return[Object(v.b)(n)]}),[n]),o=Object(u.a)(i,1)[0];return Object(x.jsx)(m.a,{layers:r,points:o,color:"white",lineWidth:.1})};var b=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,u=e.size,m=e.texture,v=e.axialTilt,b=e.bumpMap,j=(e.specularMap,e.earthCloud),f=e.distanceScale,d=e.planetGeometry,y=Object(s.a)({map:m,bumpMap:b}),h=Object(s.a)({map:j}),O=Object(a.useRef)(),g=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name}));return Object(o.c)((function(e){e.scene;var r=Date.now();g!==n&&"moon"!==g&&(O.current.rotation.y+=.1*t,O.current.position.x=Math.sin(r*(1/(200*i))+10)*f,O.current.position.z=Math.cos(r*(1/(200*i))+10)*f)})),Object(x.jsxs)(x.Fragment,{children:[Object(x.jsxs)("mesh",{layers:2,scale:u,rotation:v,name:n,position:[f,0,0],ref:O,children:[d,Object(x.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({attach:"material",fog:!1},y),{},{shininess:0,bumpScale:.005,specular:new l.Color("grey")})),Object(x.jsxs)("mesh",{layers:2,children:[Object(x.jsx)("sphereBufferGeometry",{args:[u+.005,48,48]}),Object(x.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({},h),{},{fog:!1,attach:"material",transparent:!0}))]})]}),Object(x.jsx)(p,{radius:f,layers:2})]})},j=t(51);var f=function(e){var n=e.layers,t=Object(a.useRef)(),i=Object(s.a)({map:j.a});return Object(o.c)((function(e){var n,r=null===(n=e.scene.getObjectByName("saturn"))||void 0===n?void 0:n.position;t.current.position.x=r.x,t.current.position.z=r.z})),Object(x.jsxs)("mesh",{layers:n,ref:t,position:[0,0,0],name:"saturnRing",rotation:[Math.PI/2*-26.73,0,0],children:[Object(x.jsx)("torusBufferGeometry",{args:[20,4,2,50]}),Object(x.jsx)("meshBasicMaterial",Object(r.a)({attach:"material"},i))]})};var d=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,l=e.size,u=e.texture,m=e.distanceScale,v=e.axialTilt,b=e.layers,j=e.planetGeometry,d=Object(s.a)({map:u}),y=Object(a.useRef)(),h=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name}));return Object(o.c)((function(e){var r=e.scene,a=Date.now();if(y.current.rotation.y+=.1*t,n!==h&&(y.current.position.x=Math.sin(a*(1/(200*i))+10)*m,y.current.position.z=Math.cos(a*(1/(200*i))+10)*m,"moon"===n)){var o,s=null===(o=r.getObjectByName("earth"))||void 0===o?void 0:o.position;y.current.position.x=y.current.position.x+s.x,y.current.position.z=y.current.position.z+s.z}})),Object(x.jsxs)("group",{children:[Object(x.jsxs)("mesh",{userData:!0,layers:b,scale:l,rotation:v,name:n,position:[m,0,0],ref:y,children:[j,Object(x.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({attach:"material"},d),{},{shininess:0,bumpScale:.3}))]}),Object(x.jsx)(p,{radius:m,layers:b}),"saturn"===n&&Object(x.jsx)(f,{layers:b})]})};var y=function(e){var n,t,i=e.name,l=e.rotationRate,u=e.orbitRate,m=e.size,v=e.texture,b=e.distanceScale,j=e.axialTilt,f=e.planetGeometry,d=e.layers,y=e.sphere,h=Object(s.a)({map:v}),O=Object(a.useRef)(),g=Object(a.useRef)(),w=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name})),z=Object(o.e)().scene,M=null===(n=z.getObjectByName("earth"))||void 0===n?void 0:n.position,C=null===(t=z.getObjectByName("moon"))||void 0===t?void 0:t.position,P=function(){return Object(x.jsx)(p,{radius:2.5})};return Object(o.c)((function(){var e=Date.now();O.current.rotation.y+=.1*l,i!==w&&(O.current.position.x=Math.sin(e*(1/(200*u))+10)*b,O.current.position.z=Math.cos(e*(1/(200*u))+10)*b,O.current.position.x=M.x+O.current.position.x/10,O.current.position.z=M.z+O.current.position.z/10,g.current.position.x=M.x,g.current.position.z=M.z)})),Object(x.jsxs)("group",{children:[Object(x.jsxs)("mesh",{geometry:y,layers:d,scale:m,rotation:j,name:i,position:[0,0,0],ref:O,children:[f,Object(x.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({attach:"material"},h),{},{shininess:0,bumpScale:.3}))]}),M&&C&&Object(x.jsx)("mesh",{ref:g,children:Object(x.jsx)(P,{})})]})},h=t(1),O=t(2),g=t(3),w=t(4);var z=function(e){Object(g.a)(t,e);var n=Object(w.a)(t);function t(){return Object(h.a)(this,t),n.call(this,{extensions:{derivatives:"#extension GL_OES_standard_derivatives: enable"},side:l.DoubleSide,uniforms:{time:{value:0},resolution:{value:new l.Vector4}},vertexShader:"\n    uniform float time;\n    varying vec3 vPosition;\n \n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    void main() {\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n  varying vec3 vPosition;\n\n  float PI = 3.14159265359;\n    \n  // Description : Array and textureless GLSL 2D/3D/4D simplex \n  //               noise functions.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : stegu\n  //     Lastmod : 20110822 (ijm)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //               https://github.com/ashima/webgl-noise\n  //               https://github.com/stegu/webgl-noise\n  // \n\n  vec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n  float mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n  vec4 permute(vec4 x) {\n      return mod289(((x*34.0)+10.0)*x);\n  }\n\n  float permute(float x) {\n      return mod289(((x*34.0)+10.0)*x);\n  }\n\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  float taylorInvSqrt(float r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  vec4 grad4(float j, vec4 ip)\n    {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n    return p;\n    }\n              \n  // (sqrt(5) - 1)/4 = F4, used once below\n  #define F4 0.309016994374947451\n\n  float snoise(vec4 v)\n    {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n    i = mod289(i); \n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n              i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n    }\n\n    float fbm(vec4 p) {\n      float sum = 0.;\n      float amp = 1.;\n      float scale = 1.;\n      for(int i = 0;i < 8;i++) {\n        sum += snoise(p*scale)*amp;\n        p.w += 100.;\n        amp *= .9;\n        scale += 2.;\n      }\n      return sum;\n    }\n  void main() {\n    vec4 p = vec4(vPosition*.4,time*0.05);\n    float noisy = fbm(p);\n\n    vec4 p1 = vec4(vPosition*.2,time*.05);\n    float spots = max(snoise(p1), 0.);\n\n    gl_FragColor = vec4(noisy);\n    gl_FragColor *= mix(1., spots, 0.5);\n  }\n  "})}return Object(O.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}}]),t}(l.ShaderMaterial);Object(o.b)({SunMaterial:z});var M=function(e){Object(g.a)(t,e);var n=Object(w.a)(t);function t(){return Object(h.a)(this,t),n.call(this,{extensions:{derivatives:!0},side:l.DoubleSide,uniforms:{time:{value:0},uPerlin:{value:null},resolution:{value:new l.Vector4}},vertexShader:"\n    uniform float time;\n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    \n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n  \n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    mat2 rotate(float a) {\n      float s = sin(a);\n      float c = cos(a);\n      return mat2(c, -s, s, c);\n    }\n    \n    void main() {\n      vNormal = normal;\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      eyeVector = normalize(worldPosition.xyz - cameraPosition);\n\n      float t = time*.005;\n\n      mat2 rot = rotate(t);\n      vec3 p0 = position;      \n      p0.yz = rot*p0.yz;\n      vLayer0 = p0;\n\n      mat2 rot1 = rotate(t*1.5 + 10.);\n      vec3 p1 = position;      \n      p1.xz = rot1*p1.xz;\n      vLayer1 = p1;\n\n      mat2 rot2 = rotate(t*2.0 + 30.);\n      vec3 p2 = position;      \n      p2.xy = rot2*p2.xy;\n      vLayer2 = p2;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n  uniform samplerCube uPerlin;\n\n  varying vec3 eyeVector;\n  varying vec3 vNormal;\n\n  float PI = 3.14159265359;\n  \n  varying vec3 vLayer0;\n  varying vec3 vLayer1;\n  varying vec3 vLayer2;\n\n  float Fresnel(vec3 eyeVector, vec3 worldNormal) {\n    return pow(1.0 + dot(eyeVector, worldNormal),3.0);\n  }\n\n  vec3 brightnessToColor(float b) {\n    b *= 0.25;\n    return (vec3(b, b*b, b*b*b*b)/0.25)*0.6;\n  }\n  \n  float supersun() {\n    float sum = 0.;\n    sum += textureCube(uPerlin, vLayer0).r;\n    sum += textureCube(uPerlin, vLayer1).r;\n    sum += textureCube(uPerlin, vLayer2).r;\n    sum += 0.33;\n    return sum;\n  }\n\n  void main() {\n   float brightness = supersun();\n   brightness = brightness*.9 + 1.;\n\n   float fres = Fresnel(eyeVector, vNormal);\n\n   brightness += pow(fres,2.8);\n\n   vec3 col = brightnessToColor(brightness);\n\n   gl_FragColor = vec4(col,1.0);\n\n  }\n  "})}return Object(O.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}},{key:"uPerlin",get:function(){return this.uniforms.uPerlin.value},set:function(e){this.uniforms.uPerlin.value=e}}]),t}(l.ShaderMaterial);Object(o.b)({PerlinMaterial:M});var C=function(e){Object(g.a)(t,e);var n=Object(w.a)(t);function t(){return Object(h.a)(this,t),n.call(this,{side:l.BackSide,uniforms:{viewVector:{type:"v3",value:new l.Vector3(0,0,0)}},vertexShader:"\n  varying vec3 vNormal;\n\n  void main() \n  {\n    vNormal = normalize( normalMatrix * normal );\n \n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n",fragmentShader:"\n  varying vec3 vNormal;\n\n  vec3 brightnessToColor(float b) {\n    b *= 0.25;\n    return (vec3(b, b*b, b*b*b*b)/0.25)*0.6;\n  }\n\n  void main() \n  {\n    float radial = 1. - vNormal.z;\n    radial *= radial*radial;\n   \n    float brightness = 1. + radial*.4 ;\n    vec3 glow = brightnessToColor(brightness)*radial ;\n\n    gl_FragColor.rgb = glow;\n    gl_FragColor.a = radial;\n\n  }\n  ",blending:l.AdditiveBlending,transparent:!0})}return Object(O.a)(t,[{key:"viewVector",get:function(){return this.uniforms.viewVector.value},set:function(e){this.uniforms.viewVector.value=e}}]),t}(l.ShaderMaterial);Object(o.b)({AroundMaterial:C});var P=function(){var e=Object(a.useRef)(),n=Object(a.useRef)(),t=Object(a.useRef)(),r=Object(a.useRef)(),i=Object(c.a)((function(e){return e.activePlanet})),s=Object(a.useMemo)((function(){return[new l.WebGLCubeRenderTarget(256,{format:l.RGBFormat,generateMipmaps:!0,minFilter:l.LinearMipMapLinearFilter,encoding:l.sRGBEncoding})]}),[]),m=Object(u.a)(s,1)[0];Object(o.c)((function(t,i){n.current.time+=i,e.current.time+=i,e.current.uPerlin=m.texture,r.current.update(t.gl,t.scene)}));var v=Object(a.useMemo)((function(){return Object(x.jsx)("sphereBufferGeometry",{args:[25,40,40]})}),[]);return Object(x.jsxs)(x.Fragment,{children:[Object(x.jsxs)("mesh",{layers:1,name:"sun",position:[0,0,0],children:[v,Object(x.jsx)("sunMaterial",{ref:n})]}),i&&"sun"===i.name&&Object(x.jsxs)("mesh",{children:[Object(x.jsx)("sphereBufferGeometry",{args:[30,30,30]}),Object(x.jsx)("aroundMaterial",{ref:t})]}),Object(x.jsxs)("mesh",{layers:1,children:[Object(x.jsx)("cubeCamera",{layers:1,name:"cubeCamera",ref:r,position:[0,0,0],args:[.1,26,m]}),v,Object(x.jsx)("perlinMaterial",{ref:e})]})]})};var S=function(e){var n=e.planetGeometry,t=Object(s.a)({map:i.e.texture}),o=Object(a.useRef)();return Object(x.jsxs)("mesh",{layers:i.e.layers,scale:i.e.size,name:i.e.name,position:[0,0,0],ref:o,children:[n,Object(x.jsx)("meshPhongMaterial",Object(r.a)({emissive:"#fc9601",emissiveIntensity:.7,attach:"material"},t))]})};n.default=function(){var e=Object(a.useMemo)((function(){return Object(x.jsx)("sphereBufferGeometry",{args:[1,40,40]})}),[]),n=v.a.name;return Object(o.c)((function(e){e.camera})),Object(x.jsxs)(x.Fragment,{children:["safari"===n?Object(x.jsx)(S,{planetGeometry:e}):Object(x.jsx)(P,{}),Object(x.jsx)(b,Object(r.a)(Object(r.a)({},i.a),{},{planetGeometry:e}),i.a.name),Object(x.jsx)(y,Object(r.a)({planetGeometry:e},i.c),i.c.name),i.d.map((function(n){return Object(x.jsx)(d,Object(r.a)({planetGeometry:e},n),n.name)}))]})}}}]);
//# sourceMappingURL=7.c41f3fcd.chunk.js.map