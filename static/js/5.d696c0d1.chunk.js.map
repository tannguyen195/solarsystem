{"version":3,"sources":["components/GalaxyGenerate/shaderGalaxy/GalaxyMaterial.js","components/GalaxyGenerate/shaderGalaxy/vertex.glsl.js","components/GalaxyGenerate/shaderGalaxy/fragment.glsl.js","components/GalaxyGenerate/GalaxyGenerate.js"],"names":["GalaxyMaterial","vertexColors","depthWrite","blending","THREE","uniforms","uSize","value","uTime","vertexShader","fragmentShader","this","v","extend","GalaxyGenerate","count","radius","branches","random","randomnessPower","insideColor","outsideColor","layers","shader","useRef","useMemo","positions","Float32Array","colors","scales","randomness","colorInside","colorOutside","i","pointRadius","Math","branchAngle","PI","cos","sin","toArray","randomX","pow","randomY","randomZ","mixedColor","clone","lerp","r","g","b","useFrame","state","delta","current","name","attachObject","array","itemSize","ref"],"mappings":"qLAMqBA,E,kDACnB,aAAe,uCACP,CACJC,cAAc,EACdC,YAAY,EACZC,SAAUC,mBACVC,SAAU,CACRC,MAAO,CAAEC,MAAO,IAChBC,MAAO,CAACD,MAAO,IAEjBE,aCfE,4jCDgBFC,eEhBE,ipB,uCFoBN,WACE,OAAOC,KAAKN,SAASG,MAAMD,O,IAG7B,SAAUK,GACR,OAAOD,KAAKN,SAASG,MAAMD,MAAQK,M,GApBKR,kBAwB5CS,YAAO,CAAEb,mB,WGwFMc,UAhHf,YAWI,IAAD,IAVDC,aAUC,MAVO,IAUP,MARDC,cAQC,MARQ,EAQR,MAPDC,gBAOC,MAPU,EAOV,MANDC,cAMC,MANQ,GAMR,MAJDC,uBAIC,MAJiB,EAIjB,MAHDC,mBAGC,MAHa,UAGb,MAFDC,oBAEC,MAFc,UAEd,MADDC,cACC,MADQ,GACR,EACKC,EAASC,mBADd,EAE+CC,mBAAQ,WAStD,IARA,IAAMC,EAAY,IAAIC,aAAqB,EAARZ,GAC7Ba,EAAS,IAAID,aAAqB,EAARZ,GAC1Bc,EAAS,IAAIF,aAAqB,EAARZ,GAC1Be,EAAa,IAAIH,aAAqB,EAARZ,GAE9BgB,EAAc,IAAI3B,QAAYgB,GAC9BY,EAAe,IAAI5B,QAAYiB,GAE5BY,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAE9B,IAAMC,EAAcC,KAAKjB,SAAWF,EAE9BoB,EAAgBH,EAAIhB,EAAYA,EAAYkB,KAAKE,GAAK,EAE5D,IAAIjC,UACF+B,KAAKG,IAAIF,GAAeF,EACxB,EACAC,KAAKI,IAAIH,GAAeF,GACxBM,QAAQd,EAAe,EAAJO,GAGrB,IAAMQ,EACJN,KAAKO,IAAIP,KAAKjB,SAAUC,IACvBgB,KAAKjB,SAAW,GAAM,GAAK,GAC5BA,EACAgB,EACIS,EACJR,KAAKO,IAAIP,KAAKjB,SAAUC,IACvBgB,KAAKjB,SAAW,GAAM,GAAK,GAC5BA,EACAgB,EACIU,EACJT,KAAKO,IAAIP,KAAKjB,SAAUC,IACvBgB,KAAKjB,SAAW,GAAM,GAAK,GAC5BA,EACAgB,EAEF,IAAI9B,UAAcqC,EAASE,EAASC,GAASJ,QAAQV,EAAgB,EAAJG,GAGjE,IAAMY,EAAad,EAAYe,QAC/BD,EAAWE,KAAKf,EAAcE,EAAclB,GAE5C,IAAIZ,UAAcyC,EAAWG,EAAGH,EAAWI,EAAGJ,EAAWK,GAAGV,QAC1DZ,EACI,EAAJK,GAIFJ,EAAOI,GAAKE,KAAKjB,SAEnB,MAAO,CAACQ,EAAWE,EAAQC,EAAQC,KAClC,CACDf,EACAC,EACAC,EACAE,EACAC,EACAC,EACAH,IA9DD,mBAEMQ,EAFN,KAEiBE,EAFjB,KAEyBC,EAFzB,KAEiCC,EAFjC,KAmED,OAHAqB,aAAS,SAACC,EAAOC,GACf9B,EAAO+B,QAAQ9C,OAAS6C,KAGxB,yBAAQE,KAAK,gBAAgBjC,OAAQA,EAArC,UACE,2CACE,iCACEkC,aAAc,CAAC,aAAc,YAC7BzC,MAAOA,EACP0C,MAAO/B,EACPgC,SAAU,IAEZ,iCACEF,aAAc,CAAC,aAAc,SAC7BzC,MAAOA,EACP0C,MAAO7B,EACP8B,SAAU,IAEZ,iCACEF,aAAc,CAAC,aAAc,UAC7BzC,MAAOA,EACP0C,MAAO5B,EACP6B,SAAU,IAEZ,iCACEF,aAAc,CAAC,aAAc,eAC7BzC,MAAOA,EACP0C,MAAO3B,EACP4B,SAAU,OAId,gCAAgBC,IAAKpC,EAAQrB,YAAY,EAAOD,cAAc","file":"static/js/5.d696c0d1.chunk.js","sourcesContent":["import * as THREE from \"three\";\nimport { extend } from \"@react-three/fiber\";\n\nimport vertex from \"./vertex.glsl.js\";\nimport fragment from \"./fragment.glsl.js\";\n\nexport default class GalaxyMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      vertexColors: true,\n      depthWrite: false,\n      blending: THREE.AdditiveBlending,\n      uniforms: {\n        uSize: { value: 30 },\n        uTime: {value: 0}\n      },\n      vertexShader: vertex(),\n      fragmentShader: fragment(),\n    });\n  }\n\n  get uTime() {\n    return this.uniforms.uTime.value \n  }\n\n  set uTime(v) {\n    return this.uniforms.uTime.value = v\n  }\n}\n\nextend({ GalaxyMaterial });\n","export default function vertex() {\n  return `\n    uniform float uSize;\n    uniform float uTime;\n\n    varying vec3 vColor;\n\n    attribute float aScale;\n    attribute vec3 aRandomness;\n    \n\n    float PI = 3.14159265359;\n    void main() {\n      /**\n       * Position\n       */\n      vec4 modelPosition  = modelMatrix * vec4(position, 1.0);\n\n      // Spin\n      float angle = atan(modelPosition.x, modelPosition.z);\n      float distanceToCenter = length(modelPosition.xz);\n      float angleOffet = (1.0 / distanceToCenter) * uTime * 0.2;\n      angle += angleOffet;\n      modelPosition.x = cos(angle) * distanceToCenter;\n      modelPosition.z = sin(angle) * distanceToCenter;\n      \n      //Randomness\n      modelPosition.xyz += aRandomness;\n \n\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectedPosition = projectionMatrix * viewPosition;\n      gl_Position = projectedPosition;\n      /**\n       * Size\n       */\n      gl_PointSize = aScale * uSize;\n      gl_PointSize *= ( 1.0 / - viewPosition.z );\n\n      /**\n       * Color\n       */\n      vColor = color;\n    }\n`;\n}\n","export default function fragment() {\n  return `\n  varying vec3 vColor;\n\n  void main()\n  {\n      // // Disc\n      // float strength = distance(gl_PointCoord, vec2(0.5));\n      // strength = step(0.5, strength);\n      // strength = 1.0 - strength;\n  \n      // // Diffuse point\n      // float strength = distance(gl_PointCoord, vec2(0.5));\n      // strength *= 2.0;\n      // strength = 1.0 - strength;\n  \n      // Light point\n      float strength = distance(gl_PointCoord, vec2(0.5));\n      strength = 1.0 - strength;\n      strength = pow(strength, 10.0);\n  \n      // Final color\n      vec3 color = mix(vec3(0.0), vColor, strength);\n      gl_FragColor = vec4(color, 1.0);\n  }\n  `\n}\n","import * as THREE from \"three\";\nimport { useMemo, useRef } from \"react\";\n\nimport \"./shaderGalaxy/GalaxyMaterial\";\nimport { useFrame } from \"@react-three/fiber\";\n\nfunction GalaxyGenerate({\n  count = 200000,\n\n  radius = 5,\n  branches = 3,\n  random = 0.2,\n\n  randomnessPower = 3,\n  insideColor = \"#ff6030\",\n  outsideColor = \"#1b3984\",\n  layers = 11,\n}) {\n  const shader = useRef();\n  const [positions, colors, scales, randomness] = useMemo(() => {\n    const positions = new Float32Array(count * 3);\n    const colors = new Float32Array(count * 3);\n    const scales = new Float32Array(count * 1);\n    const randomness = new Float32Array(count * 3);\n\n    const colorInside = new THREE.Color(insideColor);\n    const colorOutside = new THREE.Color(outsideColor);\n\n    for (let i = 0; i < count; i++) {\n      //Position\n      const pointRadius = Math.random() * radius;\n\n      const branchAngle = ((i % branches) / branches) * Math.PI * 2;\n\n      new THREE.Vector3(\n        Math.cos(branchAngle) * pointRadius,\n        0,\n        Math.sin(branchAngle) * pointRadius\n      ).toArray(positions, i * 3);\n\n      //Randomness\n      const randomX =\n        Math.pow(Math.random(), randomnessPower) *\n        (Math.random() < 0.5 ? 1 : -1) *\n        random *\n        pointRadius;\n      const randomY =\n        Math.pow(Math.random(), randomnessPower) *\n        (Math.random() < 0.5 ? 1 : -1) *\n        random *\n        pointRadius;\n      const randomZ =\n        Math.pow(Math.random(), randomnessPower) *\n        (Math.random() < 0.5 ? 1 : -1) *\n        random *\n        pointRadius;\n\n      new THREE.Vector3(randomX, randomY, randomZ).toArray(randomness, i * 3);\n\n      //Color\n      const mixedColor = colorInside.clone();\n      mixedColor.lerp(colorOutside, pointRadius / radius);\n\n      new THREE.Vector3(mixedColor.r, mixedColor.g, mixedColor.b).toArray(\n        colors,\n        i * 3\n      );\n\n      // Scale\n      scales[i] = Math.random();\n    }\n    return [positions, colors, scales, randomness];\n  }, [\n    count,\n    radius,\n    branches,\n    randomnessPower,\n    insideColor,\n    outsideColor,\n    random,\n  ]);\n  useFrame((state, delta) => {\n    shader.current.uTime += delta;\n  });\n  return (\n    <points name=\"The Milky Way\" layers={layers}>\n      <bufferGeometry>\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={count}\n          array={positions}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={count}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"aScale\"]}\n          count={count}\n          array={scales}\n          itemSize={1}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"aRandomness\"]}\n          count={count}\n          array={randomness}\n          itemSize={3}\n        />\n      </bufferGeometry>\n\n      <galaxyMaterial ref={shader} depthWrite={false} vertexColors={true} />\n    </points>\n  );\n}\n\nexport default GalaxyGenerate;\n"],"sourceRoot":""}