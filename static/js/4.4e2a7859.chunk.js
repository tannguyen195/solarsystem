(this.webpackJsonpsolarsystem=this.webpackJsonpsolarsystem||[]).push([[4],{67:function(e,n,t){"use strict";t.d(n,"a",(function(){return s}));var r=t(13),i=t(11),a=t(18),o=function(e){return e===Object(e)&&!Array.isArray(e)&&"function"!==typeof e};function s(e){var n=Object(a.d)(i.TextureLoader,o(e)?Object.values(e):e);if(o(e)){var t=Object.keys(e),s={};return t.forEach((function(e){return Object.assign(s,Object(r.a)({},e,n[t.indexOf(e)]))})),s}return n}s.preload=function(e){return a.d.preload(i.TextureLoader,e)},s.clear=function(e){return a.d.clear(i.TextureLoader,e)}},68:function(e,n,t){"use strict";t.r(n);var r=t(10),i=t(26),a=t(5),o=t(18),s=t(67),c=t(16),u=t(11),l=t(12),v=t(9);var m=function(e){var n=e.radius,t=Object(a.useMemo)((function(){for(var e=new Float32Array(384),t=0;t<=128;t++){var r=t/128*Math.PI*2;new u.Vector3(Math.cos(r)*n,0,Math.sin(r)*n).toArray(e,3*t)}return[e]}),[n]),r=Object(l.a)(t,1)[0];return Object(v.jsx)("line",{layers:14,children:Object(v.jsx)("bufferGeometry",{children:Object(v.jsx)("bufferAttribute",{attachObject:["attributes","position"],count:128,array:r,itemSize:3})})})};var x=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,l=e.size,x=e.texture,p=e.axialTilt,f=e.bumpMap,b=(e.specularMap,e.earthCloud),j=e.distanceScale,d=e.planetGeometry,y=Object(s.a)({map:x,bumpMap:f}),h=Object(s.a)({map:b}),O=Object(a.useRef)(),g=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name}));return Object(o.c)((function(e){e.scene;var r=Date.now();g!==n&&"moon"!==g&&(O.current.rotation.y+=.1*t,O.current.position.x=Math.sin(r*(1/(200*i))+10)*j,O.current.position.z=Math.cos(r*(1/(200*i))+10)*j)})),Object(v.jsxs)(v.Fragment,{children:[Object(v.jsxs)("mesh",{layers:2,scale:l,rotation:p,name:n,position:[j,0,0],ref:O,children:[d,Object(v.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({attach:"material",fog:!1},y),{},{shininess:0,bumpScale:.005,specular:new u.Color("grey")})),Object(v.jsxs)("mesh",{layers:2,children:[Object(v.jsx)("sphereBufferGeometry",{args:[l+.005,48,48]}),Object(v.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({},h),{},{fog:!1,attach:"material",transparent:!0}))]})]}),Object(v.jsx)(m,{radius:j,layers:2})]})},p=t(48);var f=function(e){var n=e.layers,t=Object(a.useRef)(),i=Object(s.a)({map:p.a});return Object(o.c)((function(e){var n,r=null===(n=e.scene.getObjectByName("saturn"))||void 0===n?void 0:n.position;t.current.position.x=r.x,t.current.position.z=r.z})),Object(v.jsxs)("mesh",{layers:n,ref:t,position:[0,0,0],name:"saturnRing",rotation:[Math.PI/2*-26.73,0,0],children:[Object(v.jsx)("torusBufferGeometry",{args:[20,4,2,50]}),Object(v.jsx)("meshBasicMaterial",Object(r.a)({attach:"material"},i))]})};var b=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,u=e.size,l=e.texture,x=e.distanceScale,p=e.axialTilt,b=e.layers,j=e.planetGeometry,d=Object(s.a)({map:l}),y=Object(a.useRef)(),h=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name}));return Object(o.c)((function(e){var r=e.scene,a=Date.now();if(y.current.rotation.y+=.1*t,n!==h&&(y.current.position.x=Math.sin(a*(1/(200*i))+10)*x,y.current.position.z=Math.cos(a*(1/(200*i))+10)*x,"moon"===n)){var o,s=null===(o=r.getObjectByName("earth"))||void 0===o?void 0:o.position;y.current.position.x=y.current.position.x+s.x,y.current.position.z=y.current.position.z+s.z}})),Object(v.jsxs)("group",{children:[Object(v.jsxs)("mesh",{userData:!0,layers:b,scale:u,rotation:p,name:n,position:[x,0,0],ref:y,children:[j,Object(v.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({attach:"material"},d),{},{shininess:0,bumpScale:.3}))]}),Object(v.jsx)(m,{radius:x,layers:b}),"saturn"===n&&Object(v.jsx)(f,{layers:b})]})};var j=function(e){var n=e.name,t=e.rotationRate,i=e.orbitRate,u=e.size,l=e.texture,m=e.distanceScale,x=e.axialTilt,p=e.planetGeometry,f=e.layers,b=e.sphere,j=Object(s.a)({map:l}),d=Object(a.useRef)(),y=Object(c.a)((function(e){var n;return null===(n=e.activePlanet)||void 0===n?void 0:n.name})),h=Object(o.e)().scene;return Object(o.c)((function(){var e=Date.now();if(d.current.rotation.y+=.1*t,n!==y){var r;d.current.position.x=Math.sin(e*(1/(200*i))+10)*m,d.current.position.z=Math.cos(e*(1/(200*i))+10)*m;var a=null===(r=h.getObjectByName("earth"))||void 0===r?void 0:r.position;d.current.position.x=a.x+d.current.position.x/10,d.current.position.z=a.z+d.current.position.z/10}})),Object(v.jsxs)("mesh",{geometry:b,layers:f,scale:u,rotation:x,name:n,position:[0,0,0],ref:d,children:[p,Object(v.jsx)("meshStandardMaterial",Object(r.a)(Object(r.a)({attach:"material"},j),{},{shininess:0,bumpScale:.3}))]})},d=t(1),y=t(2),h=t(3),O=t(4);var g=function(e){Object(h.a)(t,e);var n=Object(O.a)(t);function t(){return Object(d.a)(this,t),n.call(this,{extensions:{derivatives:"#extension GL_OES_standard_derivatives: enable"},side:u.DoubleSide,uniforms:{time:{value:0},resolution:{value:new u.Vector4}},vertexShader:"\n    uniform float time;\n    varying vec3 vPosition;\n \n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    void main() {\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n  varying vec3 vPosition;\n\n  float PI = 3.14159265359;\n    \n  // Description : Array and textureless GLSL 2D/3D/4D simplex \n  //               noise functions.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : stegu\n  //     Lastmod : 20110822 (ijm)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //               https://github.com/ashima/webgl-noise\n  //               https://github.com/stegu/webgl-noise\n  // \n\n  vec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n  float mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n  vec4 permute(vec4 x) {\n      return mod289(((x*34.0)+10.0)*x);\n  }\n\n  float permute(float x) {\n      return mod289(((x*34.0)+10.0)*x);\n  }\n\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  float taylorInvSqrt(float r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  vec4 grad4(float j, vec4 ip)\n    {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n    return p;\n    }\n              \n  // (sqrt(5) - 1)/4 = F4, used once below\n  #define F4 0.309016994374947451\n\n  float snoise(vec4 v)\n    {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n    i = mod289(i); \n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n              i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n    }\n\n    float fbm(vec4 p) {\n      float sum = 0.;\n      float amp = 1.;\n      float scale = 1.;\n      for(int i = 0;i < 8;i++) {\n        sum += snoise(p*scale)*amp;\n        p.w += 100.;\n        amp *= .9;\n        scale += 2.;\n      }\n      return sum;\n    }\n  void main() {\n    vec4 p = vec4(vPosition*.4,time*0.005);\n    float noisy = fbm(p);\n\n    vec4 p1 = vec4(vPosition*.2,time*.005);\n    float spots = max(snoise(p1), 0.);\n\n    gl_FragColor = vec4(noisy);\n    gl_FragColor *= mix(1., spots, 0.5);\n  }\n  "})}return Object(y.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}}]),t}(u.ShaderMaterial);Object(o.b)({SunMaterial:g});var z=function(e){Object(h.a)(t,e);var n=Object(O.a)(t);function t(){return Object(d.a)(this,t),n.call(this,{extensions:{derivatives:!0},side:u.DoubleSide,uniforms:{time:{value:0},uPerlin:{value:null},resolution:{value:new u.Vector4}},vertexShader:"\n    uniform float time;\n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    \n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n  \n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    mat2 rotate(float a) {\n      float s = sin(a);\n      float c = cos(a);\n      return mat2(c, -s, s, c);\n    }\n    \n    void main() {\n      vNormal = normal;\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      eyeVector = normalize(worldPosition.xyz - cameraPosition);\n\n      float t = time*.005;\n\n      mat2 rot = rotate(t);\n      vec3 p0 = position;      \n      p0.yz = rot*p0.yz;\n      vLayer0 = p0;\n\n      mat2 rot1 = rotate(t*1.5 + 10.);\n      vec3 p1 = position;      \n      p1.xz = rot1*p1.xz;\n      vLayer1 = p1;\n\n      mat2 rot2 = rotate(t*2.0 + 30.);\n      vec3 p2 = position;      \n      p2.xy = rot2*p2.xy;\n      vLayer2 = p2;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n  uniform samplerCube uPerlin;\n\n  varying vec3 eyeVector;\n  varying vec3 vNormal;\n\n  float PI = 3.14159265359;\n  \n  varying vec3 vLayer0;\n  varying vec3 vLayer1;\n  varying vec3 vLayer2;\n\n  float Fresnel(vec3 eyeVector, vec3 worldNormal) {\n    return pow(1.0 + dot(eyeVector, worldNormal),3.0);\n  }\n\n  vec3 brightnessToColor(float b) {\n    b *= 0.25;\n    return (vec3(b, b*b, b*b*b*b)/0.25)*0.6;\n  }\n  \n  float supersun() {\n    float sum = 0.;\n    sum += textureCube(uPerlin, vLayer0).r;\n    sum += textureCube(uPerlin, vLayer1).r;\n    sum += textureCube(uPerlin, vLayer2).r;\n    sum += 0.33;\n    return sum;\n  }\n\n  void main() {\n   float brightness = supersun();\n   brightness = brightness*.9 + 1.;\n\n   float fres = Fresnel(eyeVector, vNormal);\n\n   brightness += pow(fres,2.8);\n\n   vec3 col = brightnessToColor(brightness);\n\n   gl_FragColor = vec4(col,1.0);\n\n  }\n  "})}return Object(y.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}},{key:"uPerlin",get:function(){return this.uniforms.uPerlin.value},set:function(e){this.uniforms.uPerlin.value=e}}]),t}(u.ShaderMaterial);Object(o.b)({PerlinMaterial:z});var w=function(e){Object(h.a)(t,e);var n=Object(O.a)(t);function t(){return Object(d.a)(this,t),n.call(this,{side:u.BackSide,uniforms:{time:{value:0},resolution:{value:new u.Vector4}},vertexShader:"\n    uniform float time;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    uniform vec2 pixels;\n    float PI = 3.14159265359;\n    \n    void main() {\n      vPosition = position;\n      vNormal = normal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.); \n    }\n",fragmentShader:"\n  uniform float time; \n  uniform float progress; \n  uniform sampler2D texture1;\n  uniform vec4 resolution;\n\n  varying vec2 vUv;\n  varying vec3 vNormal;\n  varying vec3 vPosition;\n\n  float PI = 3.14159265359;\n\n  vec3 brightnessToColor(float b) {\n    b *= 0.25;\n    return (vec3(b, b*b, b*b*b*b)/0.25)*0.6;\n  }\n  \n  void main() {\n    float radial = 1. - vNormal.z;\n    radial *= radial* radial;\n\n    float brightness = 1. + radial*0.83;\n\n    gl_FragColor.rgb = brightnessToColor(brightness)*radial;\n    gl_FragColor.a = radial;\n    // float intensity = pow(.5 - dot(vNormal, vec3(0.5,0,0.)), 2.);\n    // gl_FragColor = vec4(1., .6, .4, 1.) * intensity;\n  }\n  ",blending:u.AdditiveBlending})}return Object(y.a)(t,[{key:"time",get:function(){return this.uniforms.time.value},set:function(e){this.uniforms.time.value=e}},{key:"uPerlin",get:function(){return this.uniforms.uPerlin.value},set:function(e){this.uniforms.uPerlin.value=e}}]),t}(u.ShaderMaterial);Object(o.b)({AroundMaterial:w});var M=function(){var e=Object(a.useRef)(),n=Object(a.useRef)(),t=Object(a.useRef)(),r=Object(a.useMemo)((function(){return[new u.WebGLCubeRenderTarget(256,{format:u.RGBFormat,generateMipmaps:!0,minFilter:u.LinearMipMapLinearFilter,encoding:u.sRGBEncoding})]}),[]),i=Object(l.a)(r,1)[0];Object(o.c)((function(r,a){n.current.time+=a,e.current.time+=a,e.current.uPerlin=i.texture,t.current.update(r.gl,r.scene)}));var s=Object(a.useMemo)((function(){return Object(v.jsx)("sphereBufferGeometry",{args:[25,40,40]})}),[]);return Object(v.jsxs)(v.Fragment,{children:[Object(v.jsxs)("mesh",{layers:1,name:"sun",position:[0,0,0],children:[s,Object(v.jsx)("sunMaterial",{ref:n})]}),Object(v.jsxs)("mesh",{layers:1,children:[Object(v.jsx)("cubeCamera",{layers:1,name:"cubeCamera",ref:t,position:[0,0,0],args:[.1,26,i]}),s,Object(v.jsx)("perlinMaterial",{ref:e})]})]})},P=t(47);var C=function(e){var n=e.planetGeometry,t=Object(s.a)({map:i.e.texture}),o=Object(a.useRef)();return Object(v.jsxs)("mesh",{layers:i.e.layers,scale:i.e.size,name:i.e.name,position:[0,0,0],ref:o,children:[n,Object(v.jsx)("meshPhongMaterial",Object(r.a)({emissive:"#fc9601",emissiveIntensity:.7,attach:"material"},t))]})};n.default=function(){var e=Object(a.useMemo)((function(){return Object(v.jsx)("sphereBufferGeometry",{args:[1,40,40]})}),[]),n=P.a.name;return Object(o.c)((function(e){e.camera})),Object(v.jsxs)(v.Fragment,{children:["safari"===n?Object(v.jsx)(C,{planetGeometry:e}):Object(v.jsx)(M,{}),Object(v.jsx)(x,Object(r.a)(Object(r.a)({},i.a),{},{planetGeometry:e}),i.a.name),Object(v.jsx)(j,Object(r.a)({planetGeometry:e},i.c),i.c.name),i.d.map((function(n){return Object(v.jsx)(b,Object(r.a)({planetGeometry:e},n),n.name)}))]})}}}]);
//# sourceMappingURL=4.4e2a7859.chunk.js.map