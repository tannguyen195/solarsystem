{"version":3,"sources":["../node_modules/@react-three/drei/core/useTexture.js","../node_modules/three-stdlib/lines/LineSegmentsGeometry.js","../node_modules/three-stdlib/lines/LineMaterial.js","../node_modules/three-stdlib/lines/LineSegments2.js","../node_modules/three-stdlib/lines/LineGeometry.js","../node_modules/three-stdlib/lines/Line2.js","../node_modules/@react-three/drei/core/Line.js"],"names":["IsObject","url","Object","Array","isArray","useTexture","input","textures","useLoader","TextureLoader","values","keys","keyed","forEach","key","assign","indexOf","preload","clear","LineSegmentsGeometry","_defineProperty","Box3","Vector3","setIndex","setAttribute","Float32BufferAttribute","matrix","start","this","attributes","instanceStart","end","instanceEnd","undefined","applyMatrix4","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","array","lineSegments","Float32Array","console","error","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","geometry","setPositions","from","position","mesh","fromWireframeGeometry","WireframeGeometry","isBufferGeometry","setFromBufferAttribute","box","union","Sphere","center","getCenter","maxRadiusSq","i","il","count","vector","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","InstancedBufferGeometry","LineUniforms","linewidth","value","resolution","Vector2","dashScale","dashSize","dashOffset","gapSize","opacity","ShaderLib","uniforms","UniformsUtils","merge","UniformsLib","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","Color","defineProperties","color","enumerable","get","diffuse","set","colorObj","getHex","copy","alphaToCoverage","Boolean","defines","ALPHA_TO_COVERAGE","extensions","derivatives","dashed","USE_DASH","setValues","ShaderMaterial","LineSegments2","_geometry","_material","random","lineDistances","data","j","l","distStart","distEnd","distanceTo","instanceDistanceBuffer","Vector4","Matrix4","Line3","raycaster","intersects","camera","ray","projectionMatrix","material","lineWidth","near","at","ssOrigin","w","matrixWorldInverse","multiplyScalar","x","y","z","ssOrigin3","matrixWorld","mvMatrix","multiplyMatrices","rayStart","rayEnd","deltaDist","t","lerp","line","param","closestPointToPointParameter","closestPoint","zPos","MathUtils","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","origin","face","faceIndex","object","uv","Mesh","LineGeometry","length","points","Line2","Line","React","ref","vertexColors","rest","line2","lineMaterial","lineGeom","geom","pValues","map","p","toArray","flat","cValues","c","setColors","computeLineDistances","dispose","_extends","attach"],"mappings":"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","file":"static/js/4.4c915972.chunk.js","sourcesContent":["import { TextureLoader } from 'three';\nimport { useLoader } from '@react-three/fiber';\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input) {\n  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input);\n\n  if (IsObject(input)) {\n    const keys = Object.keys(input);\n    const keyed = {};\n    keys.forEach(key => Object.assign(keyed, {\n      [key]: textures[keys.indexOf(key)]\n    }));\n    return keyed;\n  } else {\n    return textures;\n  }\n}\n\nuseTexture.preload = url => useLoader.preload(TextureLoader, url); // @ts-expect-error new in r3f 7.0.5\n\n\nuseTexture.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { IsObject, useTexture };\n","import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { InstancedBufferGeometry, Box3, Vector3, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Sphere } from 'three';\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"isLineSegmentsGeometry\", true);\n\n    _defineProperty(this, \"type\", 'LineSegmentsGeometry');\n\n    _defineProperty(this, \"boundingBox\", null);\n\n    _defineProperty(this, \"boundingSphere\", null);\n\n    _defineProperty(this, \"box\", new Box3());\n\n    _defineProperty(this, \"vector\", new Vector3());\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    } else {\n      console.error('LineSegmentsGeometry.setPosition requires either a Float32Array or regular array of numbers');\n      return this;\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    } else {\n      console.error('LineSegmentsGeometry.setColors requires either a Float32Array or regular array of numbers');\n      return this;\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(Array.from(geometry.attributes.position.array));\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(Array.from(geometry.attributes.position.array));\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));\n    return this;\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isBufferGeometry) {\n      this.setPositions(Array.from(geometry.attributes.position.array)); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n      this.box.setFromBufferAttribute(end);\n      this.boundingBox.union(this.box);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n\n      if (this.boundingBox) {\n        this.boundingBox.getCenter(center);\n      }\n\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        this.vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(this.vector));\n        this.vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(this.vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n}\n\nexport { LineSegmentsGeometry };\n","import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters = {}) {\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", new Color(0x000000));\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          const colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };\n","import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Mesh, Vector3, InstancedInterleavedBuffer, InterleavedBufferAttribute, Vector4, Matrix4, Line3, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nclass LineSegments2 extends Mesh {\n  constructor(_geometry = new LineSegmentsGeometry(), _material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(_geometry, _material);\n\n    _defineProperty(this, \"type\", 'LineSegments2');\n\n    _defineProperty(this, \"isLineSegments2\", true);\n\n    _defineProperty(this, \"distStart\", new Vector3());\n\n    _defineProperty(this, \"distEnd\", new Vector3());\n\n    _defineProperty(this, \"computeLineDistances\", () => {\n      const geometry = this.geometry;\n      const instanceStart = geometry.attributes.instanceStart;\n      const instanceEnd = geometry.attributes.instanceEnd;\n      const lineDistances = new Float32Array(2 * instanceStart.data.count);\n\n      for (let i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        this.distStart.fromBufferAttribute(instanceStart, i);\n        this.distEnd.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + this.distStart.distanceTo(this.distEnd);\n      }\n\n      const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    });\n\n    _defineProperty(this, \"rayStart\", new Vector4());\n\n    _defineProperty(this, \"rayEnd\", new Vector4());\n\n    _defineProperty(this, \"ssOrigin\", new Vector4());\n\n    _defineProperty(this, \"ssOrigin3\", new Vector3());\n\n    _defineProperty(this, \"mvMatrix\", new Matrix4());\n\n    _defineProperty(this, \"line\", new Line3());\n\n    _defineProperty(this, \"closestPoint\", new Vector3());\n\n    _defineProperty(this, \"raycast\", (raycaster, intersects) => {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n\n      const threshold = 0;\n      const ray = raycaster.ray;\n      const camera = raycaster.camera;\n      const projectionMatrix = camera.projectionMatrix;\n      const geometry = this.geometry;\n      const material = this.material;\n      const resolution = material.resolution;\n      const lineWidth = material.linewidth + threshold;\n      const instanceStart = geometry.attributes.instanceStart;\n      const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n      const near = -camera.near; // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n\n      ray.at(1, this.ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n      this.ssOrigin.w = 1;\n      this.ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      this.ssOrigin.applyMatrix4(projectionMatrix);\n      this.ssOrigin.multiplyScalar(1 / this.ssOrigin.w); // screen space\n\n      this.ssOrigin.x *= resolution.x / 2;\n      this.ssOrigin.y *= resolution.y / 2;\n      this.ssOrigin.z = 0;\n      this.ssOrigin3.set(this.ssOrigin.x, this.ssOrigin.y, this.ssOrigin.z);\n      const matrixWorld = this.matrixWorld;\n      this.mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n      for (let i = 0, l = instanceStart.count; i < l; i++) {\n        this.rayStart.fromBufferAttribute(instanceStart, i);\n        this.rayEnd.fromBufferAttribute(instanceEnd, i);\n        this.rayStart.w = 1;\n        this.rayEnd.w = 1; // camera space\n\n        this.rayStart.applyMatrix4(this.mvMatrix);\n        this.rayEnd.applyMatrix4(this.mvMatrix); // skip the segment if it's entirely behind the camera\n\n        const isBehindCameraNear = this.rayStart.z > near && this.rayEnd.z > near;\n\n        if (isBehindCameraNear) {\n          continue;\n        } // trim the segment if it extends behind camera near\n\n\n        if (this.rayStart.z > near) {\n          const deltaDist = this.rayStart.z - this.rayEnd.z;\n          const t = (this.rayStart.z - near) / deltaDist;\n          this.rayStart.lerp(this.rayEnd, t);\n        } else if (this.rayEnd.z > near) {\n          const deltaDist = this.rayEnd.z - this.rayStart.z;\n          const t = (this.rayEnd.z - near) / deltaDist;\n          this.rayEnd.lerp(this.rayStart, t);\n        } // clip space\n\n\n        this.rayStart.applyMatrix4(projectionMatrix);\n        this.rayEnd.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n        this.rayStart.multiplyScalar(1 / this.rayStart.w);\n        this.rayEnd.multiplyScalar(1 / this.rayEnd.w); // screen space\n\n        this.rayStart.x *= resolution.x / 2;\n        this.rayStart.y *= resolution.y / 2;\n        this.rayEnd.x *= resolution.x / 2;\n        this.rayEnd.y *= resolution.y / 2; // create 2d segment\n\n        this.line.start.set(this.rayStart.x, this.rayStart.y, this.rayStart.z);\n        this.line.start.z = 0;\n        this.line.end.set(this.rayEnd.x, this.rayEnd.y, this.rayEnd.z);\n        this.line.end.z = 0; // get closest point on ray to segment\n\n        const param = this.line.closestPointToPointParameter(this.ssOrigin3, true);\n        this.line.at(param, this.closestPoint); // check if the intersection point is within clip space\n\n        const zPos = MathUtils.lerp(this.rayStart.z, this.rayEnd.z, param);\n        const isInClipSpace = zPos >= -1 && zPos <= 1;\n        const isInside = this.ssOrigin3.distanceTo(this.closestPoint) < lineWidth * 0.5;\n\n        if (isInClipSpace && isInside) {\n          this.line.start.fromBufferAttribute(instanceStart, i);\n          this.line.end.fromBufferAttribute(instanceEnd, i);\n          this.line.start.applyMatrix4(matrixWorld);\n          this.line.end.applyMatrix4(matrixWorld);\n          const pointOnLine = new Vector3();\n          const point = new Vector3();\n          ray.distanceSqToSegment(this.line.start, this.line.end, point, pointOnLine);\n          intersects.push({\n            distance: ray.origin.distanceTo(point),\n            point: point,\n            face: null,\n            faceIndex: i,\n            object: this,\n            uv: undefined,\n            pointOnLine\n          });\n        }\n      }\n    });\n  }\n\n}\n\nexport { LineSegments2 };\n","import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"type\", 'LineGeometry');\n\n    _defineProperty(this, \"isLineGeometry\", true);\n\n    _defineProperty(this, \"setColors\", array => {\n      // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n      const length = array.length - 3;\n      const colors = new Float32Array(2 * length);\n\n      for (let i = 0; i < length; i += 3) {\n        colors[2 * i] = array[i];\n        colors[2 * i + 1] = array[i + 1];\n        colors[2 * i + 2] = array[i + 2];\n        colors[2 * i + 3] = array[i + 3];\n        colors[2 * i + 4] = array[i + 4];\n        colors[2 * i + 5] = array[i + 5];\n      }\n\n      super.setColors(colors);\n      return this;\n    });\n\n    _defineProperty(this, \"fromLine\", line => {\n      const geometry = line.geometry;\n\n      if (geometry.isBufferGeometry) {\n        this.setPositions(Array.from(geometry.attributes.position.array)); // assumes non-indexed\n      } // set colors, maybe\n\n\n      return this;\n    });\n\n    _defineProperty(this, \"copy\", () => {\n      // todo\n      return this;\n    });\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    const length = array.length - 3;\n    const points = new Float32Array(2 * length);\n\n    for (let i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n}\n\nexport { LineGeometry };\n","import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { LineSegments2 } from './LineSegments2.js';\nimport { LineGeometry } from './LineGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n\n    _defineProperty(this, \"type\", 'Line2');\n\n    _defineProperty(this, \"isLine2\", true);\n  }\n\n}\n\nexport { Line2 };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Vector2, Vector3, Color } from 'three';\nimport { Line2, LineMaterial, LineGeometry } from 'three-stdlib';\n\nconst Line = /*#__PURE__*/React.forwardRef(function Line({\n  points,\n  color = 'black',\n  vertexColors,\n  lineWidth,\n  dashed,\n  ...rest\n}, ref) {\n  const [line2] = React.useState(() => new Line2());\n  const [lineMaterial] = React.useState(() => new LineMaterial());\n  const [resolution] = React.useState(() => new Vector2(512, 512));\n  const lineGeom = React.useMemo(() => {\n    const geom = new LineGeometry();\n    const pValues = points.map(p => p instanceof Vector3 ? p.toArray() : p);\n    geom.setPositions(pValues.flat());\n\n    if (vertexColors) {\n      const cValues = vertexColors.map(c => c instanceof Color ? c.toArray() : c);\n      geom.setColors(cValues.flat());\n    }\n\n    return geom;\n  }, [points, vertexColors]);\n  React.useLayoutEffect(() => {\n    line2.computeLineDistances();\n  }, [points, line2]);\n  React.useLayoutEffect(() => {\n    if (dashed) {\n      lineMaterial.defines.USE_DASH = '';\n    } else {\n      // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.\n      delete lineMaterial.defines.USE_DASH;\n    }\n\n    lineMaterial.needsUpdate = true;\n  }, [dashed, lineMaterial]);\n  React.useEffect(() => {\n    return () => lineGeom.dispose();\n  }, [lineGeom]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: line2,\n    ref: ref\n  }, rest), /*#__PURE__*/React.createElement(\"primitive\", {\n    object: lineGeom,\n    attach: \"geometry\"\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: lineMaterial,\n    attach: \"material\",\n    color: color,\n    vertexColors: Boolean(vertexColors),\n    resolution: resolution,\n    linewidth: lineWidth,\n    dashed: dashed\n  }, rest)));\n});\n\nexport { Line };\n"],"sourceRoot":""}